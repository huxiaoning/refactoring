# 动机

<br>

多态的最根本好处在于：你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制会为你安排妥当。

当某个字段内容是`null`时，多态可扮演另一个较不直观(亦较不为人所知)的用途。

让我们先听听`Ron Jeffries`的故事。

------

——`Ron Jeffrics `

我们第一次使用`Null Object`模式，是因为`Rich Garzaniti`发现，系统在向对象发送一个消息之前，总要检查对象是否存在，这样的检查出现很多次。

我们可能会向一个对象索求它所相关的`Person`对象，然后再问那个对象是否为`null`。

如果对象的确存在，我们才能调用它的`rate()`函数以查询这个人的薪资级别。

我们在好些地方都是这样做的，造成的重复代码让我们很烦心。

<br>

所以，我们编写了一个`MissingPerson`类，让它返回'0'薪资等级[我们也把空对象`(null object)`称为虚拟对象`(missing object)`]。

很快地，`MissingPerson`就有了很多函数，`rate()`自然是其中之一。

如今我们的系统有超过80个空对象类。

<br>

我们常常在显示信息的时候使用空对象。

例如我们想要显示一个`Person`对象信息，它大约有20个实例变量。

如果这些变量可被设为`null`，那么打印一个`Person`对象的工作将非常复杂。

所以我们不让实例变量被设为`null`，而是插入各式各样的空对象——它们都知道如何正确地显示自己。

这样，我们就可以摆脱大量过程化的代码。

<br>

我们对空对象的最聪明运用，就是拿它来表示不存在的`Gemstone`会话：

我们使用`Gemstone`数据库来保存成品(程序代码)，但我们更愿意在没有数据库的情况下进行开发，每过一周左右再把新代码放进`Gemstone`数据库。

然而在代码的某些地方，我们必须登录一个`Gemstone`会话。

当没有`Gemstone`数据库时，我们就仅仅安插一个“虚构的`Gemstone`会话”，其接口和真正的`Gemstone`会话一模一样，使我们无需判断数据库是否存在，就可以进行开发和测试。

<br>

空对象的另一个用途是表现出“虚构的箱仓”`(missing bin)`，

所谓“箱仓”，这里是指集合，用来保存某些薪资值，并常常需要对各个薪资值进行加和或遍历。

如果某个籍仓不存在，我们就给出一个虚构的箱仓对象，其行为和一个空箱仓一样。

这个虚构箱仓知道自己其实不带任何数据，总值为0。

通过这种做法，我们就不必为上千位员工每人产生数十来个空箱对象了.

<br>

使用空对象时有个非常有趣的性质：系统几乎从来不会因为空对象而被破坏。

由于空对象对所有外界请求的响应都和真实对象一样，所以系统行为总是正常的。

但这并非总是好事，有时会造成问题的侦测和查找上的困难，因为从来没有任何东西被破坏。

当然，只要认真检查一下，你就会发现空对象有时出现在不该出现的地方。

<br>

请记住：空对象一定是常量，它们的任何成分都不会发生变化。

因此我们可以使用·Singleton·模式`[Gang of Four]`来实现它们。

例如不管任何时候，只要你索求一个`MissingPerson`对象，得到的一定是`MissingPerson`的唯一实例。 

------

<br>

关于`Null Object`模式，你可以在`Woolf [Woolf]`中找到更详细的介绍。

<br>


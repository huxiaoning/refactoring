# 2.4 怎么对经理说

<br>

“该怎么跟经理说重构的事？”

这是我最常被问到的一个问题。

如果这位经理懂技术，那么向他介绍重构应该不会很困难。

如果这位经理只对质量感兴趣，那么问题就集中到了“质量”，上面。

此时，在复审过程中使用重构就是一个不错的办法。

大量研究结果显示，技术复审是减少错误、提高开发速度的一条重要途径。

随便找一本关于复审、审查或软件开发程序的书看看，从中找些最新引证，应该可以让大多数经理认识复审的价值。

然后你就可以把重构当作“将复审意见引入代码内”的方法来使用，这很容易。

<br>

当然，很多经理嘴巴上说自己“质量驱动”，其实更多是“进度驱动”。

这种情况下我会给他们一个较有争议的建议：不要告诉经理！

<br>

这是在搞破坏吗？我不这样想。

软件开发者都是专业人士。

我们的工作就是尽可能快速创造出高效软件。

我的经验告诉我，对于快速创造软件，重构可带来巨大帮助。

如果需要添加新功能，而原本设计却又使我无法方便地修改，我发现先重构再添加新功能会更快些。

如果要修补错误，就得先理解软件的工作方式，而我发现重构是理解软件的最快方式。

受进度驱动的经理要我尽可能快速完事，至于怎么完成，那就是我的事了。

我认为最快的方式就是重构，所以我就重构。

<br>

##### 间接层和重构 —— Kent Beck

“计算机科学是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决。”

##### 间接层和重构 —— Dennis DeBruler

由于软件工程师对间接层如此醉心，你应该不会惊讶大多数重构都为程序引入了更多间接层。

重构往往把大型对象拆成多个小型对象，把大型函数拆成多个小型函数。

但是，间接层是一柄双刃剑。每次把一个东西分成两份，你就需要多管理一个东两。

如果某个对象委托另一对象，后者又委托另一对象，程序会愈加难以阅读。

基于这个观点，你会希望尽量减少间接层。

别急，伙计！间接层有它的价值。下面就是间接层的某些价值。

- **允许逻辑共享**。比如说一个子函数在两个不同的地点被调用，或超类中的某个函数被所有子类共享。
- **分开解释意图和实现**。你可以选择每个类和函数的名字，这给了你一个解释自己意图的机会。类或函数内部则解释实现这个意图的做法。如果类和函数内部又以更小单元的意图来编写，你所写的代码就可以描述其结构中的大部分重要信息。
- **隔离变化**。很可能我在两个不同地点使用同一对象，其中一个地点我想改变对象行为，但如果修改了它，我就要冒同时影响两处的风险。为此我做出一个子类，并在需要修改处引用这个子类。现在，我可以修改这个子类而不必承担无意中影响另一处的风险。
- **封装条件逻辑**。对象有一种奇妙的机制：多态消息，可以灵活而清晰地表达条件逻辑。将条件逻辑转化为消息形式，往往能降低代码的重复、增加清晰度并提高弹性。

这就是重构游戏：在保持系统现有行为的前提下，如何才能提高系统的质量或降低其成本，从而使它更有价值？

这个游戏中最常见的变量就是：你如何看待你自己的程序。找出一个缺乏“间接层利益”之处，在不修改现有行为的前提下，为它加入一个间接层。现在你获得了一个更有价值的程序，因为它有较高的质量，让我们在明天（未来）受益。

请将这种方法与“小心翼翼的事前设计”做个比较。推测性设计总是试图在任何一行代码诞生之前就先让系统拥有所有优秀质量，然后程序员将代码塞进这个强健的骨架中就行了。这个过程的问题在于：太容易猜错。如果运用重构，你就永远不会面临全盘错误的危险。程序自始至终都能保持一致的行为，而你又有机会为程序添加更多价值不菲的质量。

还有一种比较少见的重构游戏：找出不值得的间接层，并将它拿掉。这种间接层常以中介函数形式出现，它也许曾经有过贡献，但芳华已逝。它也可能是个组件，你本来期望在不同地点共享它，或让它表现出多态性，最终却只在一处用到。如果你找到这种“寄生式间接层”，请把它扔掉。如此一来你会获得一个更有价值的程序，不是因为它取得了更多的优秀质量，而是因为它以更少的间接层获得一样多的优秀质量。

<br>


# 2.5 重构的难题

<br>

学习一种可以大幅提高生产力的新技术时，你总是难以察觉其不适用的场合。

通常你在一个特定场景中学习它，这个场景往往是个项目。

这种情况下你很难看出什么会造成这种新技术成效不彰甚或形成危害。

十年前，对象技术的情况也是如此。

那时如果有人问我何时不要使用对象，我很难回答。

并非我认为对象十全十美、没有局限性—我最反对这种盲目态度，而是尽管我知道它的好处，但确实不知道其局限性在哪儿。

<br>

现在，重构的处境也是如此。

我们知道重构的好处，我们知道重构可以给我们的工作带来立竿见影的改变。

但是我们还没有获得足够的经验，我们还看不到它的局限性。

<br>

这一节比我希望的要短。

暂且如此吧。

随着更多人学会重构技巧，我们也将对它有更多了解。

对你而言这意味着：虽然我坚决认为你应该尝试一下重构，获得它所提供的利益，但与此同时，你也应该时时监控其过程，注意寻找重构可能引入的问题。

请让我们知道你所遭遇的问题。

随着对重构的了解日益增多，我们将找出更多解决办法，并清楚知道哪些问题是真正难以解决的。

<br>

## 数据库

<br>

重构经常出问题的一个领域就是数据库。

绝大多数商用程序都与它们背后的数据库结构紧密耦合在一起，这也是数据库结构如此难以修改的原因之一。

另一个原因是数据迁移（migration），就算你非常小心地将系统分层，将数据库结构和对象模型间的依赖降至最低，但数据库结构的改变还是让你不得不迁移所有数据，

这可能是件漫长而烦琐的工作。

<br>

在非对象数据库中，解决这个问题的办法之一就是：在对象模型和数据库模型之间插入一个分隔层，这就可以隔离两个模型各自的变化。

升级某一模型时无需同时升级另一模型，只需升级上述的分隔层即可。

这样的分隔层会增加系统复杂度，但可以给你带来很大的灵活度。

如果你同时拥有多个数据库，或如果数据库模型较为复杂使你难以控制，那么即使不进行重构，这分隔层也是很重要的。

<br>

你无需一开始就插入分隔层，可以在发现对象模型变得不稳定时再产生它，这样你就可以为你的改变找到最好的平衡点。

<br>

对开发者而言，对象数据库既有帮助也有妨碍。

某些面向对象数据库提供不同版本的对象之间的自动迁移功能，这减少了数据迁移时的工作量，但还是会损失一定时间。如果各数据库之间的数据迁移并非自动进行，你就必须自行完成迁移工作，这个工作量可是很大的。

这种情况下你必须更加留神类中的数据结构变化。

你仍然可以放心将类的行为转移过去，但转移字段时就必须格外小心。数据尚未被转移前你就得先运用访问函数造成“数据已经转移”的假象。

一旦你确定知道数据应该放在何处，就可以一次性地将数据迁移过去。

这时唯一需要修改的只有访问函数，这也降低了错误风险[^1]。

<br>

## 修改接口

<br>

关于对象，另一件重要事情是：它们允许你分开修改软件模块的实现和接口。

你可以安全地修改对象内部实现而不影响他人，但对于接口要特别谨慎—如果接口被修改了，任何事情都有可能发生。

<br>

一直对重构带来困扰的一件事就是：许多重构手法的确会修改接口。

像RenameMethod （273）这么简单的重构手法所做的一切就是修改接口。

这对极为珍贵的封装概念会带来什么影响呢？

<br>

如果某个函数的所有调用者都在你的控制之下，那么即使修改函数名称也不会有任何问题。

哪怕面对一个public函数，只要能取得并修改其所有调用者，你也可以安心地将这个函数改名。

只有当需要修改的接口被那些“找不到，即使找到也不能修改”的代码使用时，接口的修改才会成为问题。

如果情况真是如此，我就会说：这个接口是个已发布接口（published interface）—比公开接口（public interface）更进一步。

接口一旦发布，你就再也无法仅仅修改调用者而能够安全地修改接口了。

你需要一个更复杂的流程。

<br>

这个想法改变了我们的问题。

如今的问题是：该如何面对那些必须修改“已发布接口"的重构手法？

<br>

简言之，如果重构手法改变了已发布接口，你必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应。

幸运的是，这不太困难。

你通常都有办法把事情组织好，让旧接口继续工作。

请尽量这么做：让旧接口调用新接口。

当你要修改某个函数名称时，请留下旧函数，让它调用新函数。

千万不要复制函数实现，那会让你陷入重复代码的泥淖中难以自拔。

你还应该使用Java提供的deprecation （不建议使用）设施，将旧接口标记为deprecated，这么一来你的调用者就会注意到它了。

<br>

这个过程的一个好例子就是Java容器类（集合类， collection classes）。

Java 2的新容器取代了原先一些容器。

当Java 2容器发布时， JavaSoft花了很大力气来为开发者提供一条顺利迁徙之路。

<br>

“保留旧接口”的办法通常可行，但很烦人。

起码在一段时间里你必须构造并维护一些额外的函数。

它们会使接口变得复杂，使接口难以使用。

还好我们有另一个选择：不要发布接口。

当然我不是说要完全禁止，因为很明显你总得发布一些接口。

如果你正在建造供外部使用的API （就像Sun公司所做的那样），就必须发布接口。

之所以说尽量不要发布，是因为我常常看到一些开发团队公开了太多接口。

我曾经看到一支三人团队这么工作：每个人都向另外两人公开发布接口。

这使他们不得不经常来回维护接口，而其实他们原本可以直接进入程序库，径行修改自己管理的那一部分，那会轻松许多。

过度强调代码所有权的团队常常会犯这种错误。

发布接口很有用，但也有代价。

所以除非真有必要，不要发布接口。

这可能意味需要改变你的代码所有权观念，让每个人都可以修改别人的代码，以适应接口的改动。

以结对编程的方式完成这一切通常是个好主意。

<br>

> 不要过早发布接口。请修改你的代码所有权政策，使重构更顺畅。

<br>

Java还有一种特别的接口修改：在throws子句中增加一个异常。

这并不是对函数签名的修改，所以你无法以委托的办法隐藏它；但如果用户代码不做出相应修改，编译器不会让它通过。

这个问题很难解决。你可以为这个函数选择一个新名字，让旧函数调用它，并将这个新增的受控异常转换成一个非受控异常。你也可以抛出—个非受控异常，不过这样你就会失去检验能力。如果你那么做，你可以警告调用者：这个非受控异常日后会变成一个受控异常。这样他们就有时间在自己的代码中加上对此异常的处理。出于这个原因，我总是喜欢为整个包（package）定义一个异常基类（就像java.sql的SQLException），并确保所有public函数只在自己的throws子句中声明这个异常。这样我就可以随心所欲地定义异常子类，不会影响调用者，因为调用者永远只知道那个更具一般性的异常基类。

<br>

## 难以通过重构手法完成的设计改动

<br>

通过重构，可以排除所有设计错误吗？

是否存在某些核心设计决策，无法以重构手法修改？

在这个领域里，我们的统计数据尚不完整。

当然某些情况下我们可以很有效地重构，这常常令我们倍感惊讶，但的确也有难以重构的地方。

比如说在一个项目中，我们很难（但还是有可能）将不考虑安全性需求时构造起来的系统重构为具备良好安全性系统。

<br>

这种情况下我的办法就是：先想象重构的情况。

考虑候选设计方案时，我会问自己：将某个设计重构为另一个设计的难度有多大？

如果看上去很简单，我就不必太担心选择是否得当，于是我就会选最简单的设计，哪怕它不能覆盖所有潜在需求也没关系。

但如果预先看不到简单的重构办法，我就会在设计上投入更多力气。

不过我发现，后一种情况很少出现。

<br>

## 何时不该重构

<br>

有时候你根本不应该重构，例如当你应该重新编写所有代码的时候。

有时候既有代码实在太混乱，重构它还不如重新写一个来得简单。

作出这种决定很困难，我承认我也没有什么好准则可以判断何时应该放弃重构。

<br>

重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作。

你可能只是试着做点测试，然后就发现代码中满是错误，根本无法稳定运作。

记住，重构之前，代码必须起码能够在大部分情况下正常运作。

<br>

一个折中办法就是：将“大块头软件”重构为封装良好的小型组件。

然后你就可以逐一对组件做出“重构或重建”的决定。

这是一个颇有希望的办法，但我还没有足够数据，所以也无法写出好的指导原则。

对于一个重要的遗留系统，这肯定会是一个很好的方向。

<br>

另外，如果项目己近最后期限，你也应该避免重构。

在此时机，从重构过程赢得的生产力只有在最后期限过后才能体现出来，而那个时候已经为时晚矣。

WardCunningharm对此有一个很好的看法。

他把未完成的重构工作形容为“债务”。

很多公司都需要借债来使自己更有效地运转。

但是借债就得付利息，过于复杂的代码所造成的维护和扩展的额外成本就是利息。

你可以承受一定程度的利息，但如果利息太高你就会被压垮。

把债务管理好是很重要的，你应该随时通过重构来偿还一部分债务。

<br>

如果项目已经非常接近最后期限，你不应该再分心于重构，因为已经没有时间了。

不过多个项目经验显示：重构的确能够提高生产力。

如果最后你没有足够时间，通常就表示你其实早该进行重构。





<br>

[^1]:数据库重构的经验也已经由Soctt Ambler等人总结成书，相关内容请参考《数据库重构》(http://www.douban.com/subject/1954438/),-译者注


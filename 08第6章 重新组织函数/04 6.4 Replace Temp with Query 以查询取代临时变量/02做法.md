# 做法

<br>

首先是简单情况：

- 找出只被赋值一次的临时变量。
  - ⇒如果某个临时变量被赋值超过一次，考虑使用Split Temporary Variable（128） 将它分割成多个变量。
- 将该临时变量声明为final。
- 编译。
  - ⇒这可确保该临时变量的确只被赋值一次。
- 将“对该临时变量赋值”语句的等号右侧部分提炼到一个独立函数中。
  - ⇒首先将函数声明为private.日后你可能会发现有更多类需要使用它，那时放松对它的保护也很容易。
  - ⇒确保提炼出来的函数无任何副作用，也就是说该函数并不修改任何对象内容。如果它有副作用，就对它进行Separate Query from Modifler （279）
- 编译，测试。
- 在该临时变量身上实施Inline Temp（119）。

<br>

我们常常使用临时变量保存循环中的累加信息。

在这种情况下，整个循环都可以被提炼为一个独立函数，这也使原本的函数可以少掉几行扰人的循环逻辑。

有时候，你可能会在一个循环中累加好几个值，就像本书第26页的例子那样。

这种情况下你应该针对每个累加值重复一遍循环，这样就可以将所有临时变量都替换为查询。

当然，循环应该很简单，复制这些代码时才不会带来危险。

<br>

运用此手法，你可能会担心性能问题。

和其他性能问题一样，我们现在不管它，因为它十有八九根本不会造成任何影响。

若是性能真的出了问题，你也可以在优化时期解决它。

代码组织良好，你往往能够发现更有效的优化方案：如果没有进行重构，好的优化方案就可能与你失之交臂。

如果性能实在太糟糕，要把临时变量放回去也是很容易的。

<br>


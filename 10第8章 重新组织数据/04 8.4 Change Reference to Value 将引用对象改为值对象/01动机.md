# 动机

<br>

正如我在`Change Value to Reference (179)`中所说，要在引用对象和值对象之间做选择，有时并不容易。

作出选择后，你常会需要一条回头路。

<br>

如果引用对象开始变得难以使用，也许就应该将它改为值对象。

引用对象必须被某种方式控制，你总是必须向其控制者请求适当的引用对象。

它们可能造成内存区域之间错综复杂的关联。

在分布系统和并发系统中，不可变的值对象特别有用，因为你无需考虑它们的同步问题。

<br>

值对象有一个非常重要的特性：它们应该是不可变的。

无论何时，只要你调用同一对象的同一个查询函数，都应该得到同样结果。

如果保证了这一点，就可以放心地以多个对象表示同一个事物。

如果值对象是可变的，你就必须确保对某一对象的修改会自动更新其他“代表相同事物”的对象。

这太痛苦了，与其如此还不如把它变成引用对象。

<br>

这里有必要澄清一下“不可变” `(immutable)`的意思。

如果你以Money类表示“钱”的概念，其中有“币种”和“金额”两条信息，那么Money对象通常是一个不可变的值对象。

这并非意味你的薪资不能改变，

而是意味：如果要改变你的薪资，就需要使用另一个`Money`对象来取代现有的`Money`对象，而不是在现有的`Money`对象上修改。

你和`Money`对象之间的关系可以改变，但`Money`对象自身不能改变。

<br>


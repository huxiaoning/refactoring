# 3.7 Feature Envy 依恋情结

<br>

对象技术的全部要点在于：这是一种“将数据和对数据的操作行为包装在一起”的技术。

有一种经典气味是：函数对某个类的兴趣高过对自己所处类的兴趣。

这种孺慕之情最通常的焦点便是数据。

无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。

疗法显而易见：把这个函数移至另一个地点。

你应该使用Move Method （142）把它移到它该去的地方。

有时候函数中只有一部分受这种依恋之苦，这时候你应该使用Extract Method （110）把这一部分提炼到独立函数中，再使用Move Method （142）带它去它的梦中家园。

<br>

当然，并非所有情况都这么简单。

一个函数往往会用到几个类的功能，那么它究竟该被置于何处呢？

我们的原则是：判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。

如果先以Extract Method （110）将这个函数分解为数个较小函数并分别置放于不同地点，上述步骤也就比较容易完成了

<br>

有几个复杂精巧的模式破坏了这个规则。

说起这个话题， GoF[Gangof Four]的Strategy和Visitor立刻跳入我的脑海， Kent Beck的Self Delegation[Beck]也在此列。

使用这些模式是为了对抗坏味道Divergent Change，最根本的原则是：将总是一起变化的东西放在一块儿。

数据和引用这些数据的行为总是一起变化的，但也有例外。

如果例外出现，我们就搬移那些行为，保持变化只在一地发生。

Strategy和Visitor使你得以轻松修改函数行为，因为它们将少量需被覆写的行为隔离开来—当然也付出了“多一层间接性”的代价。

<br>


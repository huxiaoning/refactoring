# 5.3 这些重构手法有多成熟

<br>

任何技术作家都会面对这样一个问题：该在何时发表自己的想法？

发表愈早，人们愈快能够运用新想法、新观念。

但只要是人，总是不断在学习。

如果过早发表半生不熟的想法，这些思想可能并不完善，甚至可能给那些尝试采用它们的人带来麻烦。

<br>

重构的基本技巧—小步前进、频繁测试—已经得到多年的实践检验，特别是在Smalltalk社群中。所以，我敢保证，重构的这些基础思想是非常可靠的。

<br>

本书中的重构手法是我自己使用重构的笔记。

是的，我全都用过它们。

但是“使用某个重构手法”和“将它浓缩成可重复的做法步骤”是有区别的。

特别是在一些十分特殊的情况下，偶尔你会看见一些问题突然涌现。

我并没有让很多人进行我所写下的这些技术步骤以图发现这一类问题。

所以，使用重构的时候，请随时知道自己在做什么。

记住，就像看着食谱做菜一样，你必须让这些重构手法适应你自己的情况。

如果你遇上一个有趣的问题，请以电子邮件告诉我，我会试着把你的情况告诉其他人。

<br>

关于这些重构手法，另一个需要记住的就是：我是在“单进程软件”这一大前提下考虑并介绍它们的。

我很希望看到有人介绍用于并发和分布式程序设计的重构技术。

这样的重构将是完全不同的。

举个例子，在单进程软件中，你永远不必操心多么频繁地调用某个函数，因为函数的调用成本很低。

但在分布式软件中，函数的往返必须被减至最低限度。

在这些特殊编程领域中有着完全不同的重构术，这已超越本书主题。

<br>

许多重构手法，例如Replace Type Code with State／Strategy（227）和Form Template Method（345），都涉及向系统引入设计模式。

正如GoF的经典著作所说：“设计模式······为重构行为提供了目标。

”模式和重构之间有着一种与生俱来的关系。

模式是你希望到达的目标，重构则是到达之路。

本书并没有提供“完成所有知名模式”的重构手法，甚至连GoF的23个知名模式［Gang of Four］都没能全部覆盖。

这也从某个侧面反映出这份列表的不完整。我希望有一天这个缺陷能够被填补。

<br>

运用重构的时候，请记住：它们仅仅是一个起点。

毋庸置疑，你一定可以找出个中缺陷。

我之所以选择现在发表它们，因为我相信，尽管它们还不完美，但的确有用。

我相信它们能给你一个起点，然后你可以不断提高自己的重构能力。

这正是它们带给我的。

<br>

随着你用过愈来愈多的重构手法，我希望，你也开始发展属于自己的重构手法。

但愿本书例子能够激发你的创造力，并给你一个起点，让你知道从何入手。

我很清楚现实存在的重构，比我这里介绍的还要多得多。

如果你真地提出了一些新的重构手法，请给我一封电子邮件。

<br>


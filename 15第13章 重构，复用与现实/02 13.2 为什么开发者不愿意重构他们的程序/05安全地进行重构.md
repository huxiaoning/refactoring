# 安全地进行重构

<br>

安全性是令人关心的议题，特别对于那些开发、维护大型系统的组织更是如此。

许多应用程序背负着财政、法律和道德伦理方面的压力，必须提供不间断的、可靠的、不出错的服务。

有许多组织提供大量培训和努力，力图以严谨的开发过程来帮助他们保证产品的安全性。

<br>

但是，对很多程序员来说，安全性的问题往往没那么严重。

我们总是向孩子们灌输“安全第一”的思想，自己却扮演渴望自由的程序员、西部牛仔和血气方刚的驾驶员的角色，这实在是个莫大讽刺。

给我们自由，给我们资源，看我们飞吧。

不管怎么说，难道我们真地希望公司放弃我们的创造性果实，就为了获得可重复性和一致性吗？

<br>

这一节我将讨论安全重构的方法。

和`Martin`在本书先前章节介绍过的方法相比，我关注的方法其结构更组织化、更严格，可因此排除重构可能引入的很多错误。

<br>

安全性是一个很难定义的概念。

直观的定义是：所谓“安全重构”就是不会对程序造成破坏的重构。

由于重构的意图就是在不改变程序行为的前提下修改程序结构，所以重构后的程序行为应该与重构前完全相同。

<br>

如何进行安全重构呢？你有以下几种选择。

- 相信你自己的编码功力。
- 相信你的编译器能捕捉你遗漏的错误。
- 相信你的测试套件能捕捉你和编译器都遗漏的错误。
- 相信代码复审能捕捉你、编译器和测试套件都遗漏的错误。

Martin在他的重构原则中比较关注前三个选项。

大中型公司则常常以代码复审作为前三个步骤的补充。

<br>

尽管编译器、测试套件、代码复审、严守纪律的编码风格都很有价值，但所有这些方法还是有下列局限性。

- 程序员是可能犯错的，你也一样(我也一样)。
- 有一些微妙和不那么微妙的错误，编译器无法捕捉，特别是那些与继承相关的作用域错误。
- `Perry`、`Kaiser`和其他人已经指出，尽管“将继承作为一种实现技术”的做法让测试工作简单了不少，但由于先前向某个类的实例发出请求的很多操作如今转而向子类发出请求，我们仍然需要大量测试来覆盖这种情况。除非你的测试设计者是全知全能的上帝，或除非他对细节非常谨慎，否则就有可能出现测试套件覆盖不到的情况。是否测试了所有可能的执行路径？这是一个无法以计算判定的问题。换句话说，你无法保证测试套件覆盖所有可能情况。
- 和程序员一样，代码复审人员也是可能犯错的。而且复审人员可能因为忙于自己的主要工作，无法彻底检查别人的代码。

我在研究工作中使用的另一种方法是：定义并快速实现一个重构工具的原型，用以检查某项重构是否可以安全地施加于程序身上。

如果可以，就重构之。

这避免了大量可能因为人为错误而引入的`bug`。

<br>

在这里，我将概括介绍我的安全重构法。

这可能是本章最具价值的一部分了。

如果你想获得更详细的信息，请看我的论文和本章末尾所列的参考文献，也可以参考第14章。

如果你觉得这一部分有点过分偏重技术，不妨跳过本节余下的段落。

<br>

我的重构工具的一部分是程序分析器，这是一个用来分析程序结构的程序(被分析的对象是将来打算施加某项重构的一个`C++`程序)，这个工具可以解答一系列问题，内容涉及作用域、类型和程序语义(程序的意图或用途)等方面。

作用域的问题与继承有关，所以这一分析过程比起很多非面向对象程序分析要复杂；

但`C++`的某些语言特性(例如静态类型)又使得这一分析过程比起对`Smallalk`等动态类型程序的分析要简单。

<br>

举个例子，假设我们的重构是要删除程序中的某个变量。

我的工具可以判断程序其他部分是否引用了这个变量。

如果有，径自删除这一变量将会造成引用失败，那么这项重构就是不安全的。

于是工具用户就会收到一个错误标记。

用户可能因此决定放弃进行这次重构，也可能修改程序中对此变量的引用点，使它们不再引用它，然后才进行重构，删除该变量。

这个工具还可以进行其他许多检查，其中大多数都和上述检查一样简单，有些稍微复杂。

<br>

在我的研究中，我把“安全”定义为：程序属性(包括作用域和类型等)在重构之后仍然保持不变。

很多程序属性很像数据库中的完整性约束——修改数据库结构时，完整性约束必须保持不变。

每个重构都伴随一组必要前提，如果这些前提得到满足，该重构就能保证程序属性获得维持。

一旦确定某次重构的全部过程都安全，我的工具才会执行该次重构。

<br>

幸运的是，对于重构安全性进行的检查(尤其是对于数量占绝对优势的低层重构)往往是轻而易举的。

为了保证较高层重构、较复杂重构的安全性，我们以低层重构来定义它们。

例如“建立一个抽象超类”的复杂重构手法就被定义为几个较小步骤，每个步骤都以较简单的重构完成，像是创建和搬移变量或函数等等。

只要证明复杂重构的每一个步骤是安全的，我们就可以确定整个复杂重构也是安全的。

<br>

在某些十分罕见的情况下，在工具无法确认时，仍然可以安全施行重构。

此时，工具会选择较安全的方式：禁止重构。

拿先前例子来说，你想删除程序中的某个变量，但程序其他地方对该变量有引用动作。

然而或许这个引用动作所处段落永远不会被执行到，例如它也许出现于条件表达式(如`if-then`)中，而它所处分支永远不为真。

如果肯定这个分支永远不为真，你可以移除它，连同那个影响你重构的引用点一并移除。

然后你就可以安全地进行重构，删除想删除的变量或函数了。

只不过，一般情况下你无法肯定分支永远为假——如果你继承了别人开发的代码，你有多大把握安全删掉其中某段代码？

<br>

重构工具可以标记出这种可能不安全的引用关系，并向用户提出警告。

用户可以先把这段代码放在一旁。

一旦能够肯定引用点永远不会被执行到，他就可以把这段多余代码移除，而后进行重构。

这个工具让用户知道存在这么一个隐藏的引用关系，而不是盲目地进行修改。

<br>

这听起来好像有点复杂，作为博士论文的主题倒是不错(博士论文的主要读者——论文评议委员会——比较喜欢理论性题目），但是对于实际重构有用吗？

<br>

所有这些安全性检查都可以在重构工具中实现。

如果程序员想要重构一个程序，只需以这个工具检查其代码。

如果检查结果为“安全”，就执行重构。

我的工具只是个研究雏形。

`Don Roberts`、`John Brant`、`Ralph Johnson`和我后来实现了一个体质更健壮、功能更齐备的工具(参见第14章)，这是我们对于“`Smalltalk`程序重构”研究的一部分。

<br>

重构的安全性可以分为很多级别。

有些重构很容易实施，但安全性较低。

使用重构工具有很多好处。

它可以帮我们做许多简单而乏味的检查，并标记出一些埋藏较深的问题。

如果不做这些检查，重构动作有可能导致程序完全崩溃。

<br>

编译、测试和代码复审可以指出很多错误，但也会遗漏一些错误，重构工具则可以帮助你抓住漏网之鱼。

尽管如此，编译、测试和代码复审仍然是很有价值的，在实时系统的开发和维护中更是如此。

这些系统中的程序往往不是孤立运行的，它们是大型通信系统网络中的一部分。

有些重构不但把代码清扫干净，而且会让程序跑得更快。

然而提升某个程序的速度，可能会在另一个地方造成性能瓶颈。

这就好像你升级`CPU`进而提升了部分系统性能，你需要以类似方法来调整、测试系统整体性能。

另一方面，有些重构也可能略微降低系统整体性能。

一般说来，重构对性能的影响是微不足道的。

<br>

“安全性措施”用来保证重构不会向程序引入新错误。

这些措施并不能检查或修复程序重构前就存在的错误。

但重构可以使你更容易找到并修复这些错误。

<br>


# 如何重构，在哪里重构

<br>

如何才能学会重构呢？有什么工具？有什么技术？如何把这些工具和技术组合起来做出有用的事？应该何时使用它们？

本书定义了好几十条重构做法，这些都是`Martin`在自己的工作经验中发掘的有用手法。

重构如何被用以支持程序重大修改？

本书提供了很好的例子。

<br>

在伊利诺伊大学的软件重构项目中，我们选择了一条“极简主义”路线。

我们定义了较少的一组重构，展示它们的使用方法。

我们对重构的收集建立于自己的编程经验上。

我们评估好几个面向对象框架(多数以`C++`开发完成)的结构演化，和几位经验丰富的`Smaltalk`开发者交谈并阅读他们的回顾记录。

我们收集的重构手法大多很低层，例如建立或删除一个类、一个变量或一个函数；

修改变量和函数的属性，如访问权限(`public`或`protected`)，修改函数参数等；

或者在类之间移动变量和函数。

我们以另一组数量较少的高级重构手法来处理较为复杂的情况，例如建立抽象超类，通过继承和“简化条件”等方式来简化一个类，从现有的类中分解一部分、新建一个可复用的组件类(经常会在继承、委托、聚合之间转换)，等等。

这些较复杂的重构手法是以低层重构手法定义出来的。

之所以采用这种方法，乃是为了自动化支持和安全两方面考量，我将于稍后讨论。

<br>

面对一个既有程序，我们该使用哪些重构呢？

当然，这取决于你的目标。一个常见的重构原因，同时也是本书关注焦点，是调整程序结构以使（短期内）添加新功能更容易。

我将在下一节讨论这一点。

除此之外，还有其他理由让你使用重构。

<br>

有经验的面向对象程序员和那些受过设计模式等优秀设计技巧训练的人都知道，几种好的程序结构性质量和特征能够为可扩展性和可复用性提供支持。

诸如`CRC`之类的面向对象设计技术也关注定义类和类之间的协议。

虽然它们关注的焦点是前期设计，但也可以用这些指导方针来评价一个现有程序。

<br>

自动化工具可用来识别程序中的结构缺陷，例如函数参数过多、函数过长等。

这些都应该考虑成为重构的对象。

自动化工具还可以识别出结构上的相似，这样的相似很可能代表着冗余代码的存在。

比如说，如果两个函数几乎相同(这经常是复制/修改第一个函数以获得第二个函数时造成的)，

自动化工具就会检测到这种相似性，并建议你使用一些重构手法，将相同代码搬到同一个地方去。

如果程序中不同位置的两个变量有相同名称，有时你可以使用一个变量替代它们，并在两处继承之。

这些都是非常简单的例子。

有了自动化工具，其他很多更复杂的情况都可以被检测出来并被纠正。

这些结构上的畸形或结构上的相似并非总是暗示你必须重构，但很多时候它们的确就是这个意思。

<br>

对设计模式的很多研究，都集中于良好编程风格以及程序各部分之间有用的交互模式，而这些都可以映射为结构特征和重构手法。

例如`Template Method`模式的“适用性”一节就参考了我们的超类重构手法。

<br>

我列出了一些试探法则，可以帮助你识别`C++`程序中需要重构的地方。

`John Brant`和`Don Roberts`开发出一个工具，使用更大范围的试探来自动分析`Smalltalk`程序。

这个工具会向开发者建议“可用以改进程序”的重构方法，以及适合使用这些重构方法的地点。

<br>

运用这样一个工具来分析你的程序，有点像运用`lint`来改善`C/C++`程序。

这个工具尚未聪明到能够理解程序意图。

它在程序结构分析基础上提出的建议，或许只有一部分是你真正想要做出的修改。

作为程序员，决定权在你手上。

由你决定把哪些建议用于自己的程序上。

这些修改应该改进程序的结构，应该为日后的修改提供更好的支撑。

<br>

在程序员说服自己“我应该重构我的代码”之前，他们需要先了解如何重构、在哪里重构。

经验是无可替代的。

研究过程中，我们得益于经验丰富的面向对象开发者的经验，得到了一些有用的重构做法，以及“该在哪里使用这些重构”的认识。

自动化工具可以分析程序结构，建议可能改进程序结构的重构做法。

和其他大多数学科一样，工具和技术会带来帮助，但前提是你打算使用它们。

重构过程中，程序员自己对重构的理解也会逐渐加深。

<br>


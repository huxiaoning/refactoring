# 对重构有支持能力的语言特性和编程风格

<br>

重构时，你必须找出待重构的这一部分程序被什么地方引用。

`C++`的静态类型特性让你可以比较容易地缩小搜索范围。

举个简单而常见的例子，假设你想要给`C++`类中的一个成员函数改名，为正确完成这个动作，你必须修改函数声明以及对这个函数的所有引用点。

如果程序很大，搜索、修改这些引用点会很困难。

<br>

和`Smaltalk`相比， `C++`的类继承和保护访问级别(`public`， `protected`和`private`)特性，使你更容易判断哪些地方引用了这个将被改名的函数。

如果这个函数被声明为`private`，那么引用它的代码就只可能出现在该函数所属的类内部以及被这个类声明为`friend`的地方；

如果这个函数被声明为`protected`，那么引用点只可能出现在它所属的类、它的子类(及更低层的子类)内以及它的`friend`中；

如果这个函数被声明为`public`(限制最少的一种访问级别)，引用点也只可能出现在上述`protected`所列情况，以及对函数所属类及其子孙类实例的操作之上。

<br>

在十分庞大的程序中，不同地点有可能声明一些同名函数。

有时候，两个或多个同名函数以同一个函数取代可能更好，某些重构手法可用来做这种修改；

有时候则应该给两个同名函数中的一个改名，让另一个保持原来名称。

如果项目开发成员不只一人，不同的程序员可能给风马牛不相及的函数取相同的名称。

在`C++`中，当你对两个同名函数中的一个改名之后，几乎总是很容易找到哪些引用点针对的是这个被易名函数，哪些引用点针对的是另一个函数。

这种分析在`Smaltalk`中要困难得多。

<br>

由于`C++`以继承方式来实现“子类型”的概念，所以通常可以通过将变量或函数在继承体系中移上移下来扩大(普通化)或缩小(特殊化)其作用域。

对程序做这一类分析并进行相应重构，都是很简单的。

<br>

如果在最初开发和整个开发过程中一直遵循一些良好的设计原则，那么重构过程会更轻松，软件的进化会更容易。

“将所有成员变量和大多数成员函数定义为`private`或`protected`”作为一种抽象技术，常常使类的内部重构更简单，因为对程序其他地方造成的影响被减至最低。

以继承机制表现“普通化和特殊化”体系(这在`C++`中很自然)，也使日后“泛化或特化成员变量或成员函数”的重构动作更容易进行，你只需在继承体系内上下移动这些成员即可。

<br>

`C++`环境中的很多特性都支持重构。

如果程序员在重构时引入错误，`C++`编译器通常都会指出这个错误。

许多`C++`软件开发环境都提供了强大的交叉参考和代码浏览功能。

<br>


# 做法

<br>

我们为你准备了两组重构做法。

第一种情况是：你无法确定哪些地方会发生变化。

这时候你会希望每次一小步地前进。

- 鉴别出一种变化情况。
  - ⇒如果这种变化可能在对象生命周期的不同阶段而有不同体现，就运用`Extract Class (149)`将它提炼为一个独立的类。
- 针对这种变化情况，新建一个子类，并对原始类实施`Replace Constructor with Factory Method (304)`，再修改工厂函数，令它返回适当的子类实例。
- 将含有条件逻辑的函数，一次一个，逐一复制到子类，然后在明确情况下(对子类明确，对超类不明确)，简化这些函数。
  - ⇒如有必要隔离函数中的条件逻辑和非条件逻辑，可对超类实施`Extract Method (110)`。
- 重复上述过程，将所有变化情况都分离出来，直到可以将超类声明为抽象类为止。
- 删除超类中那些被所有子类覆写的函数本体，并将它们声明为抽象函数。

如果你非常清楚原始类会有哪些变化情况，可以使用另一种做法。

- 针对原始类的每一种变化情况，建立一个子类。
- 使用`Replace Constructor with Factory Method (304)`将原始类的构造函数转变成工厂函数，并令它针对每一种变化情况返回适当的子类实例。
  - ⇒如果原始类中的各种变化情况是以类型码标示，先使用``Replace Type Code with Subclasses (223)`；如果那些变化情况在对象生命周期的不同阶段会有不同体现，请使用`Replace Type Code with State/Strategy (227)`。
- 针对带有条件逻辑的函数，实施`Replace Conditional with Polymorphism (255)`。如果并非整个函数的行为有所变化，而只是函数一部分有所变化，请先运用`Extract Method (110)`将变化部分和不变部分隔开来。

<br>


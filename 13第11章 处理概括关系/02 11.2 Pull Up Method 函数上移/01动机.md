# 动机

<br>

避免行为重复是很重要的。

尽管重复的两个函数也可以各自工作得很好，但重复自身只会成为错误的滋生地，此外别无价值。

无论何时，只要系统之内出现重复，你就会面临“修改其中一个却未能修改另一个”的风险。

通常，找出重复也有一定困难。

<br>

如果某个函数在各子类中的函数体都相同(它们很可能是通过复制粘贴得到的)，这就是最显而易见的`Pull Up Method (322)`适用场合。

当然，情况并不总是如此明显。

你也可以只管放心地重构，再看看测试程序会不会发牢骚，但这就需要对你的测试有充分的信心。

我发现，观察这些可能重复的函数之间的差异往往大有收获：它们经常会向我展示那些我忘记测试的行为。

<br>

`Pull Up Method (322)`常常紧随其他重构而被使用。

也许你能找出若干个身处不同子类内的函数，而它们又可以通过某种形式的参数调整成为相同的函数。

这时候，最简单的办法就是首先分别调整这些函数的参数，然后再将它们概括到超类中。

当然，如果你足够自信，也可以一次完成这两个步骤。

<br>

有一种特殊情况也需要使用`Pull Up Method (322)`：子类的函数覆写了超类的函数，但却仍然做相同的工作。

<br>

`Pull Up Method (322)`过程中最麻烦的一点就是：被提升的函数可能会引用只出现于子类而不出现于超类的特性。

如果被引用的是个函数，你可以将该函数也一同提升到超类，或者在超类中建立一个抽象函数。

在此过程中，你可能需要修改某个函数的签名，或建立一个委托函数。

<br>

如果两个函数相似但不相同，你或许可以先借助`Form Template Method (345)`构造出相同的函数，然后再提升它们。

<br>


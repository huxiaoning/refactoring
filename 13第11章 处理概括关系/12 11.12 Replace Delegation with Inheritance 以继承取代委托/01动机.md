# 动机

<br>

本重构与`Replace Inheritance with Delegation (352)`恰恰相反。

如果你发现自己需要使用受托类中的所有函数，并且费了很大力气编写所有极简的委托函数，本重构可以帮助你轻松回头使用继承。

<br>

两条告诫需牢记于心。

首先，如果你并没有使用受托类的所有函数，那么就不应该使用`Replace Delegation With Inheritance (355)`，因为子类应该总是遵循超类的接口。

如果过多的委托函数让你烦心，你有别的选择：你可以通过`Remove Middle Man (160)`让客户端自己调用受托函数，

也可以使用`Extract Superclass (336)`将两个类接口相同的部分提炼到超类中，然后让两个类都继承这个新的超类；

你还可以用类似的手法使用`Extract Interface (341)`。

<br>

另一种需要当心的情况是：受托对象被不止一个其他对象共享，而且受托对象是可变的。

在这种情况下，你就不能将委托关系替换为继承关系，因为这样就无法再共享数据了。

数据共享是必须由委托关系承担的一种责任，你无法把它转给继承关系。

如果受托对象是不可变的，数据共享就不成问题，因为你大可放心地复制对象，谁都不会知道。

<br>

